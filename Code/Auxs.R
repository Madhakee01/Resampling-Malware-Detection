##########################################################################
# Workflows
# define several workflows for applying the different resampling strategies for regression tasks
##########################################################################
WFnone <- function(form, train, test, learner, learner.pars){
  preds <- do.call(paste('cv', learner, sep='.'),
                   list(form, train, test, learner.pars))
  res <- list(trues=responseValues(form, test), preds=preds)
  return(res)
}


WFRandUnder <- function(form, train, test, learner, C.perc, repl, learner.pars){
  if (C.perc == "mybal"){
    newtr <-  RandUnderClassif(form, train, C.perc = list(normal = 0.3, DoS = 0.5), repl)
  } else {
    newtr <- RandUnderClassif(form, train, C.perc, repl)
  }
  preds <- do.call(paste('cv',learner,sep='.'),
                   list(form,newtr,test, learner.pars))
  res <- list(trues=responseValues(form,test),preds=preds)
  return(res)
}


WFGN <- function(form, train, test, learner, rel, C.perc, pert, repl,
                        learner.pars){
  if (C.perc == "mybal"){
    newtr <- GaussNoiseClassif(form, train, C.perc=list(normal = 0.3, DoS=0.5, probe = 2, R2L = 20, U2R = 300) , pert, repl)
  } else {
    newtr <- GaussNoiseClassif(form, train, C.perc, pert, repl)
  }
  preds <- do.call(paste('cv',learner,sep='.'),
                   list(form,newtr,test, learner.pars))
  res <- list(trues=responseValues(form,test),preds=preds)
  return(res)
}

WFsmote <- function(form, train, test, learner, C.perc, k, repl, dist, p, learner.pars){
  if (C.perc == "mybal"){
    newtr <- SmoteClassif(form, train, C.perc = list(normal = 0.3, DoS=0.5, probe = 2, R2L = 20, U2R = 300), k, repl, dist, p)
  } else {
    newtr <- SmoteClassif(form, train, C.perc, k, repl, dist, p)
  }
  preds <- do.call(paste('cv',learner,sep='.'),
                   list(form,newtr,test, learner.pars))
  res <- list(trues=responseValues(form,test),preds=preds)
  return(res)
}

WFSMOGN <- function(form, train, test, learner, method, npts, control.pts,
                   thr.rel, C.perc, k, repl, dist, p, pert, learner.pars){
  if (C.perc == "mybal"){  
    newtr <- SMOGNClassif(form, train, C.perc = list(normal = 0.3, DoS=0.5, probe = 2, R2L = 20, U2R = 300), k, repl, dist, p, pert)
  } else {
    newtr <- SMOGNClassif(form, train, C.perc, k, repl, dist, p, pert)
  }
 preds <- do.call(paste('cv',learner,sep='.'),
                  list(form,newtr,test, learner.pars))
 res <- list(trues=responseValues(form,test),preds=preds)
 return(res)
}

# define the learn/test functions for the systems
cv.svm <- function(form,train,test,learner.pars) {
  cost <- learner.pars$cost
  gamma <- learner.pars$gamma
  m <- svm(form,train, scale= FALSE, cost=cost, gamma=gamma)
  predict(m,test)
}
cv.randomForest <- function(form,train,test,learner.pars) {
  mtry <- learner.pars$mtry
  ntree <- learner.pars$ntree
  m <- randomForest(form,train, ntree=ntree, mtry=mtry)
  predict(m,test)
}

cv.earth <- function(form,train,test,learner.pars) {
  nk <- learner.pars$nk
  degree <- learner.pars$degree
  thresh <- learner.pars$thresh
  m <- earth(form,train,nk=nk, degree=degree, thresh=thresh)
  predict(m,test)[,1]
}

cv.nnet <- function(form,train,test,learner.pars){
 size <- learner.pars$size 
 decay <- learner.pars$decay
 m <- nnet(form, train, size=size, decay=decay, linout=TRUE, trace=FALSE, MaxNWts=100000)
 predict(m, test, type='class')
}

cv.rpart <- function(form,train,test,learner.pars){
  cp <- learner.pars$cp
  minsplit <- learner.pars$minsplit
  m <- rpart(form, train, cp=cp, minsplit=minsplit)
  predict(m, test, type = "class")
}

cv.gbm <- function(form,train,test,learner.pars) {
  n.trees <- learner.pars$n.trees
  interaction.depth <- learner.pars$interaction.depth
  shrinkage <- learner.pars$shrinkage
  m <- gbm(form, distribution = "multinomial", data=train,  n.trees = n.trees,
           interaction.depth = interaction.depth, shrinkage = shrinkage)
  preds <- predict(m,test, n.trees=n.trees, type = "response")
  colnames(preds)[apply(preds, 1, which.max)]
}

# ============================================================
# EVALUATION STATISTICS
# metrics definition for the estimation task
# ============================================================

eval.stats <- function(trues, preds, train, metrics) {

c(acc = performanceEstimation::classificationMetrics(trues, preds, metrics = "acc"),
  macroF= performanceEstimation::classificationMetrics(trues, preds, metrics = "macroF"),
  macroRec= performanceEstimation::classificationMetrics(trues, preds, metrics = "macroRec"),
  macroPrec= performanceEstimation::classificationMetrics(trues, preds, metrics = "macroPrec")
  
)
}
